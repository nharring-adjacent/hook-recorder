# Hook-Recorder

[![Build Status](https://travis-ci.com/nharring/hook-recorder.svg?branch=master)](https://travis-ci.com/nharring/hook-recorder) [![codecov](https://codecov.io/gh/nharring/hook-recorder/branch/master/graph/badge.svg)](https://codecov.io/gh/nharring/hook-recorder)

Simple webhook recorder written in rust which persists records to a postgres database and has a display endpoint which shows the headers and body for the most recently recorded hook.

Warp is the web framework and Diesel is the ORM in use, metrics is used for a metrics facade with metrics_runtime providing the controller and exporter.

The webapp container is very lean, using a statically compiled rust binary and a scratch container to minimize footprint as much as possible.

## Deploying

Clone repository

``` bash
git clone https://github.com/nharring/hook-recorder.git
```

Create external volume for postgres

``` bash
docker volume create db-data
```

Launch containers

``` bash
docker-compose -f "hook-recorder/docker-compose.yml" up -d
```

If you need to debug from inside the container change the Dockerfile to uncomment FROM ALPINE and comment FROM SCRATCH and rebuild.

An existing postgres installation can be used by modifying the environment vars in docker-compose.yml, if you use your own DB also be sure to remove the db service and the webapps dependency on it. You can also remove the backend bridge network in this case.

## Developing

Fork and/or clone the repository and then setup the diesel cli (see <http://diesel.rs/guides/getting-started/> for more info on getting started with Diesel.)

``` bash
cargo install diesel_cli
```

Export DATABASE_URL (or use .env) with values appropriate to your dev environment

``` bash
bash> export DATABASE_URL=postgres://user:pass@host/db
powershell> $env:DATABASE_URL='postgres://user:pass@host/db'
```

Run diesel database setup (we don't need initial setup since we have migrations from the git repo)

``` bash
diesel database setup
```

## Program structure

main.rs contains the core runloop which sets up config, builds a pool of db connections, installs the metrics facade, installs the logger, builds the filter list, establishes an atomic bool tokio::channel pair and finally spawns the warp server onto the threadpool with a graceful shutdown handler on SIGINT and SIGTERM.

The models module exposes types intended for human use Webhook and Tag for displaying, NewTag and NewWebhook for inserting via the Diesel ORM layer.

Templates all live in /templates and are Handlebars templates with several custom helpers defined in the templating module.

The schema module is autogenerated by the diesel cli via print-schema.

The tagmgr module provides create and view for new tags which can then be used with the record module's endpoints to capture webhooks and the display module's endpoints to view them.

## Missing functionality

The database structure is intended to allow for tags to be marked inactive which prevents new webhook recording but not display, and for cascading deletes when a tag is deleted however no endpoints exist yet to either toggle the active flag or to delete a tag.

Displaying webhook headers and body is fairly primitive, even pretty-printing them as json would be a marked improvement.

New tag insertion colliding with existing tag will explode messily.

Docker build caching is pretty bad leading to higher than wanted build times.

One clippy warning must be ignored "parameter of type HashMap should be generalized over different hashers" due to the insane complexity of trying to properly plumb this trait all the way through from the filter definition. The current compromise yields the most compact and readable filter definition and endpoint definition, just clippy remains unhappy.
